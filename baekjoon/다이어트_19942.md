## [ğŸ¥—](https://www.acmicpc.net/problem/19942) [19942] ë‹¤ì´ì–´íŠ¸

> **ë‚œì´ë„: ê³¨ë“œ 5<br>
> ì†Œìš” ì‹œê°„: 35ë¶„<br>
> ë©”ëª¨ë¦¬: 12548KB<br>
> ì‹œê°„: 80ms**

## ë¦¬ë·°

- ì²˜ìŒì—ëŠ” ë¶€ë¶„ì§‘í•©ìœ¼ë¡œ í’€ë ¤ê³  í–ˆìœ¼ë‚˜, ì¡°í•©ìœ¼ë¡œ í’€ë©´ ì‹œê°„ì„ ë” ë‹¨ì¶•ì‹œí‚¬ ìˆ˜ ìˆì„ ê²ƒ ê°™ì•„ì„œ í’€ì´ ë°©ì‹ì„ `ì¡°í•©`ìœ¼ë¡œ ë³€ê²½í–ˆë‹¤.

## ì „ì²´ ì½”ë“œ

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main_19942_ë‹¤ì´ì–´íŠ¸ {

    static int N;
    static int[][] input;
    static int mp, mf, ms, mv;
    static int min = -1;
    static int[] answer;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine().trim());

        StringTokenizer st = new StringTokenizer(br.readLine());
        mp = Integer.parseInt(st.nextToken());
        mf = Integer.parseInt(st.nextToken());
        ms = Integer.parseInt(st.nextToken());
        mv = Integer.parseInt(st.nextToken());

        input = new int[N][];
        for (int n = 0; n < N; n++) {
            st = new StringTokenizer(br.readLine());
            input[n] = new int[]{Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())};
        }

        comb(0, 0, new int[N], 0, 0, 0, 0, 0);
        if (min == -1) {
            System.out.println(-1);
        } else {
            StringBuilder sb = new StringBuilder();
            sb.append(min).append("\n").append(answer[0] + 1);
            for (int n = 1; n < N; n++) {
                if (answer[n] == 0) break;
                sb.append(" ").append(answer[n] + 1);
            }
            System.out.println(sb);
        }
    }

    static void comb(int idx, int st_i, int[] check, int p, int f, int s, int v, int cost) {
        if (min != -1 && cost > min) {
            return;
        }

        if (st_i == N) {
            if (mp <= p && mf <= f && ms <= s && mv <= v && (min == -1 || cost < min)) {
                min = cost;
                answer = check.clone();
            }
            return;
        }

        comb(idx, N, check, p, f, s, v, cost);
        for (int i = st_i; i < N; i++) {
            check[idx] = i;
            comb(idx + 1, i + 1, check, p + input[i][0], f + input[i][1], s + input[i][2], v + input[i][3], cost + input[i][4]);
        }
        check[idx] = 0;
    }
}

```
